#! /bin/sh /usr/share/dpatch/dpatch-run
## delay-first-read.dpatch by RÃ©mi Palancher <remi@rezib.org>
##
## DP: delay first read of plugins to next interval

diff --git a/src/collectd.conf.in b/src/collectd.conf.in
index 1f4ccf8..67a5ea8 100644
--- a/src/collectd.conf.in
+++ b/src/collectd.conf.in
@@ -50,6 +50,8 @@
 #WriteQueueLimitHigh 1000000
 #WriteQueueLimitLow   800000
 
+#SyncNodesReads false
+
 ##############################################################################
 # Logging                                                                    #
 #----------------------------------------------------------------------------#
diff --git a/src/collectd.conf.pod b/src/collectd.conf.pod
index 978c1c5..a5d4d4d 100644
--- a/src/collectd.conf.pod
+++ b/src/collectd.conf.pod
@@ -341,6 +341,17 @@ Configure the name of the "pre-cache chain" and the "post-cache chain". Please
 see L<FILTER CONFIGURATION> below on information on chains and how these
 setting change the daemon's behavior.
 
+=item B<SyncNodesReads> B<true|false>
+
+This parameter can be used to synchronize the plugin reads among multiple nodes
+on a cluster setup. When set to B<true>, the first plugin reads are delayed to
+the beginning of the next read interval. This way, if the system clocks of the
+nodes are synchronized (using NTP or similar) and the read intervals are
+equal, the plugin reads are also naturally synchronized among these nodes.
+
+The default value is B<false>. The first plugin reads are scheduled as soon as
+possible on collectd start.
+
 =back
 
 =head1 PLUGIN OPTIONS
diff --git a/src/daemon/configfile.c b/src/daemon/configfile.c
index f367ee9..e8013be 100644
--- a/src/daemon/configfile.c
+++ b/src/daemon/configfile.c
@@ -115,7 +115,8 @@ static cf_global_option_t cf_global_options[] = {
     {"CollectInternalStats", NULL, 0, "false"},
     {"PreCacheChain", NULL, 0, "PreCache"},
     {"PostCacheChain", NULL, 0, "PostCache"},
-    {"MaxReadInterval", NULL, 0, "86400"}};
+    {"MaxReadInterval", NULL, 0, "86400"},
+    {"SyncNodesReads", NULL, 0, "false"}};
 static int cf_global_options_num = STATIC_ARRAY_SIZE(cf_global_options);
 
 static int cf_default_typesdb = 1;
diff --git a/src/daemon/plugin.c b/src/daemon/plugin.c
index 51cc425..2eb5478 100644
--- a/src/daemon/plugin.c
+++ b/src/daemon/plugin.c
@@ -1108,7 +1108,45 @@ static int plugin_insert_read(read_func_t *rf) {
   int status;
   llentry_t *le;
 
-  rf->rf_next_read = cdtime();
+  cdtime_t now = cdtime();
+  cdtime_t next_read = 0;
+
+  if (IS_TRUE (global_option_get ("SyncNodesReads")))
+  {
+    /*
+     * In order to kind of "synchronize" all collectd plugin reads
+     * among various nodes, wait for the current interval to be
+     * over. This way, if all nodes clocks are properly
+     * synchronized (by NTP or so) and the read interval is the
+     * same on all nodes, the read callbacks will hopefully happen
+     * at (almost) the same time.
+     *
+     * To help understand the interval maths, here is an example
+     * timeline:
+     *
+     *                                      interval
+     *                            |------------------------->|
+     * -+-------------------------+--------------------------+->
+     *             ^              ^
+     *             |---- wait --->|
+     *            now           start
+     *
+     *  |--------->|------------->|
+     *       i1            i2
+     *
+     * i1 = now % interval
+     * i2 = interval - (now % interval)
+     *
+     * First read must be schedule at now + i2
+     */
+    next_read = now + (rf->rf_interval - (now % rf->rf_interval));
+    DEBUG ("plugin %s first read is delayed to %f to sync with "
+           "other nodes",
+           rf->rf_name,
+           CDTIME_T_TO_DOUBLE(next_read));
+  } else
+    next_read = now;
+  rf->rf_next_read = next_read;
   rf->rf_effective_interval = rf->rf_interval;
 
   pthread_mutex_lock(&read_lock);
